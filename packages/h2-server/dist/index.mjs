// src/index.ts
import * as http2 from "http2";

// src/transport.ts
import { v4 as uuid } from "uuid";
import {
  constants as http2constants
} from "http2";
import {
  AsyncEventEmitter as AsyncEventEmitter2,
  CONTROL_PATH,
  INITIATING_CHANNEL_ID_HEADER,
  STREAM_PATH
} from "@eleplug/h2";

// src/channel.ts
import serbin from "@eleplug/serbin";
import { AsyncEventEmitter, FrameParser, H2ChannelBase } from "@eleplug/h2";
var H2ServerControlChannel = class extends H2ChannelBase {
  messageEvents = new AsyncEventEmitter();
  constructor(stream) {
    const parser = new FrameParser();
    super(stream, parser);
    stream.pipe(parser);
    parser.on("data", async (frame) => {
      try {
        const message = serbin.from(frame);
        await this.messageEvents.emitAsync("message", message);
      } catch (err) {
        this.parser.destroy(err);
      }
    });
  }
  send(data) {
    const payload = Buffer.from(serbin.byteify(data));
    return this.sendFrame(payload);
  }
  /**
   * Sends a special signal to the client over the control channel.
   * This is used to request that the client open a new stream channel, enabling
   * server-initiated streams.
   * @param signal The signal to send.
   */
  sendSignal(signal) {
    const payload = Buffer.from(serbin.byteify(signal));
    return this.sendFrame(payload);
  }
  /**
   * Internal helper to enforce the replacement semantic for message handlers.
   * @private
   */
  _setListener(handler, once) {
    this.messageEvents.removeAllListeners("message");
    const eventHandler = once ? this.messageEvents.once.bind(this.messageEvents) : this.messageEvents.on.bind(this.messageEvents);
    eventHandler("message", handler);
  }
  onMessage(handler) {
    this._setListener(handler, false);
  }
  onceMessage(handler) {
    this._setListener(handler, true);
  }
};
var H2ServerStreamChannel = class extends H2ChannelBase {
  id;
  dataEvents = new AsyncEventEmitter();
  /**
   * @param stream The underlying server HTTP/2 stream.
   * @param channelId The channel's unique ID. For client-initiated streams, this
   * is typically the stream ID. For server-initiated streams, it's a UUID
   * generated by the server transport.
   */
  constructor(stream, channelId) {
    const parser = new FrameParser();
    super(stream, parser);
    this.id = channelId ?? String(stream.id);
    stream.pipe(parser);
    parser.on("data", async (frame) => {
      try {
        const message = serbin.from(frame);
        await this.dataEvents.emitAsync("data", message);
      } catch (err) {
        this.parser.destroy(err);
      }
    });
  }
  send(chunk) {
    const payload = Buffer.from(serbin.byteify(chunk));
    return this.sendFrame(payload);
  }
  /**
   * Internal helper to enforce the replacement semantic for data handlers.
   * @private
   */
  _setListener(handler, once) {
    this.dataEvents.removeAllListeners("data");
    const eventHandler = once ? this.dataEvents.once.bind(this.dataEvents) : this.dataEvents.on.bind(this.dataEvents);
    eventHandler("data", handler);
  }
  onData(handler) {
    this._setListener(handler, false);
  }
  onceData(handler) {
    this._setListener(handler, true);
  }
};

// src/transport.ts
var Http2ServerTransport = class {
  constructor(session) {
    this.session = session;
    this.closePromise = new Promise((resolve) => {
      this.resolveClosePromise = resolve;
    });
    this.controlChannelPromise = new Promise((resolve, reject) => {
      this.resolveControlChannel = resolve;
      this.rejectControlChannel = reject;
    });
    this.controlChannelPromise.catch(() => {
    });
    this.setupSessionListeners();
  }
  events = new AsyncEventEmitter2();
  onIncomingStreamHandler = null;
  state = 0 /* OPEN */;
  isControlChannelEstablished = false;
  // A promise that resolves when the client establishes the control channel.
  controlChannelPromise;
  resolveControlChannel;
  rejectControlChannel;
  /**
   * Stores resolvers for pending server-initiated streams, keyed by the
   * `channelId` sent to the client.
   */
  pendingOutgoingStreams = /* @__PURE__ */ new Map();
  closePromise;
  resolveClosePromise;
  /** Sets up listeners for critical session events. @internal */
  setupSessionListeners() {
    this.session.once("close", () => {
      const reason = this.state === 1 /* CLOSING */ ? void 0 : new Error("HTTP/2 session closed unexpectedly.");
      this.performFinalCleanup(reason);
    });
    this.session.once("error", (err) => this.performFinalCleanup(err));
    this.session.on("goaway", (errorCode, _lastStreamID, opaqueData) => {
      if (errorCode === http2constants.NGHTTP2_NO_ERROR) return;
      const reasonText = opaqueData?.length > 0 ? opaqueData.toString() : `GOAWAY received with error code ${errorCode}`;
      this.performFinalCleanup(new Error(reasonText));
    });
    this.session.on("stream", (stream, headers) => {
      try {
        this.handleIncomingStream(stream, headers);
      } catch (err) {
        console.error(
          `[H2-Server] Unhandled error processing incoming stream ${stream.id}:`,
          err
        );
        if (!stream.closed && !stream.destroyed) {
          stream.close(http2constants.NGHTTP2_INTERNAL_ERROR);
        }
      }
    });
  }
  /** Single, idempotent entry point for all transport shutdown logic. @internal */
  performFinalCleanup(reason) {
    if (this.state === 2 /* CLOSED */) return;
    this.state = 2 /* CLOSED */;
    const cleanupError = reason ?? new Error("Transport closed.");
    this.rejectControlChannel(cleanupError);
    this.pendingOutgoingStreams.forEach((pending) => {
      clearTimeout(pending.timeoutId);
      pending.reject(cleanupError);
    });
    this.pendingOutgoingStreams.clear();
    this.events.emit("close", reason);
    this.events.removeAllListeners();
    if (!this.session.destroyed) {
      this.session.destroy(
        reason,
        reason ? http2constants.NGHTTP2_INTERNAL_ERROR : http2constants.NGHTTP2_NO_ERROR
      );
    }
    this.resolveClosePromise();
  }
  /** Routes an incoming HTTP/2 stream to the appropriate handler. @internal */
  handleIncomingStream(stream, headers) {
    if (this.state !== 0 /* OPEN */) {
      if (!stream.closed) stream.close(http2constants.NGHTTP2_REFUSED_STREAM);
      return;
    }
    const path = headers[":path"];
    switch (path) {
      case CONTROL_PATH:
        this.handleControlStream(stream);
        break;
      case STREAM_PATH:
        this.handleDataStream(stream, headers);
        break;
      default:
        if (!stream.headersSent) {
          stream.respond({ ":status": 404 }, { endStream: true });
        }
        break;
    }
  }
  /** Handles the establishment of the single control channel. @internal */
  handleControlStream(stream) {
    if (this.isControlChannelEstablished) {
      console.error(
        "[H2-Server] Client attempted to open a second control channel. Rejecting."
      );
      stream.close(http2constants.NGHTTP2_PROTOCOL_ERROR);
      return;
    }
    this.isControlChannelEstablished = true;
    if (!stream.headersSent) {
      stream.respond({ ":status": 200 });
    }
    const channel = new H2ServerControlChannel(stream);
    channel.onClose((channelReason) => {
      if (this.state === 0 /* OPEN */) {
        const err = channelReason ?? new Error("Control channel closed unexpectedly.");
        this.performFinalCleanup(err);
      }
    });
    this.resolveControlChannel(channel);
  }
  /** Handles an incoming data stream (client- or server-initiated). @internal */
  handleDataStream(stream, headers) {
    const requestedChannelId = headers[INITIATING_CHANNEL_ID_HEADER];
    if (!stream.headersSent) {
      stream.respond({ ":status": 200 });
    }
    if (requestedChannelId && this.pendingOutgoingStreams.has(requestedChannelId)) {
      const pending = this.pendingOutgoingStreams.get(requestedChannelId);
      clearTimeout(pending.timeoutId);
      this.pendingOutgoingStreams.delete(requestedChannelId);
      pending.resolve({ stream, headers });
    } else {
      const handler = this.onIncomingStreamHandler;
      if (handler) {
        const channel = new H2ServerStreamChannel(stream);
        try {
          Promise.resolve(handler(channel)).catch((err) => {
            console.error(`[H2-Server] Error in onIncomingStreamChannel handler for ${channel.id}:`, err);
            channel.close();
          });
        } catch (err) {
          console.error(`[H2-Server] Sync error in onIncomingStreamChannel handler for ${channel.id}:`, err);
          channel.close();
        }
      } else {
        console.warn(`[H2-Server] No handler for client-initiated stream ${stream.id}. Closing.`);
        if (!stream.closed) {
          stream.close(http2constants.NGHTTP2_REFUSED_STREAM);
        }
      }
    }
  }
  // #region Public API (Transport Interface Implementation)
  async openOutgoingStreamChannel() {
    if (this.state !== 0 /* OPEN */) {
      throw new Error("Transport is not open.");
    }
    const controlChannel = await this.controlChannelPromise;
    if (controlChannel.isClosed) {
      throw new Error("Control channel is closed.");
    }
    const channelId = uuid();
    const streamPromise = new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.pendingOutgoingStreams.delete(channelId);
        reject(new Error(`Timeout: Client did not open stream for channel ${channelId} within 10s.`));
      }, 1e4);
      this.pendingOutgoingStreams.set(channelId, { resolve, reject, timeoutId });
    });
    await controlChannel.sendSignal({
      _h2_signal_: true,
      type: "open-stream-request",
      channelId
    });
    const { stream: h2Stream } = await streamPromise;
    return new H2ServerStreamChannel(h2Stream, channelId);
  }
  getControlChannel() {
    if (this.state === 2 /* CLOSED */) {
      return Promise.reject(new Error("Transport is closed."));
    }
    return this.controlChannelPromise;
  }
  onIncomingStreamChannel(handler) {
    this.onIncomingStreamHandler = handler;
  }
  onClose(handler) {
    this.events.on("close", handler);
  }
  close() {
    if (this.state !== 0 /* OPEN */) {
      return this.closePromise;
    }
    this.state = 1 /* CLOSING */;
    if (!this.session.closed) {
      this.session.close();
    }
    return this.closePromise;
  }
  abort(reason) {
    if (this.state === 2 /* CLOSED */) {
      return this.closePromise;
    }
    this.performFinalCleanup(reason);
    return this.closePromise;
  }
  // #endregion
};

// src/index.ts
var ServerBuilder = class {
  /**
   * @param host The host to bind to (e.g., '0.0.0.0' or 'localhost').
   * @param port The port to listen on.
   * @param options Optional Node.js `http2.createSecureServer` (for TLS) or
   * `http2.createServer` options. The presence of a `key` and `cert` will
   * determine if a secure server is created.
   */
  constructor(host, port, options) {
    this.host = host;
    this.port = port;
    this.options = options;
  }
  /**
   * Starts the HTTP/2 server and begins accepting new connections.
   *
   * @param handler A function that will be executed for each new client
   * connection (session). It receives a dedicated `Http2Transport` instance
   * for that specific client. This is where you would attach the transport
   * to an eRPC router or application logic.
   *
   * @returns The underlying Node.js `Http2Server` or `Http2SecureServer` instance.
   */
  accept(handler) {
    const isSecure = this.options && "key" in this.options && "cert" in this.options;
    const server2 = isSecure ? http2.createSecureServer(this.options) : http2.createServer();
    server2.on(
      "error",
      (err) => console.error("[H2-Server] Global Server Error:", err)
    );
    server2.on("session", (session) => {
      const transport = new Http2ServerTransport(session);
      try {
        handler(transport);
      } catch (err) {
        console.error("[H2-Server] Error in user accept handler:", err);
        if (!session.destroyed) {
          session.destroy();
        }
      }
    });
    server2.listen(this.port, this.host, () => {
      console.log(
        `[H2-Server] Listening on ${isSecure ? "https" : "http"}://${this.host}:${this.port}`
      );
    });
    return server2;
  }
};
function server(host, port, options) {
  return new ServerBuilder(host, port, options);
}
export {
  Http2ServerTransport,
  server
};
