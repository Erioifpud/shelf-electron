/**
 * @fileoverview API Implementation & Data Management
 *
 * This file contains the core business logic for the plugin. It acts as the
 * "backend" or "service layer" that is exposed to the renderer process.
 *
 * By separating this logic from the plugin's lifecycle file (`main.ts`),
 * we create a more modular and testable codebase. This file knows nothing
 * about Electron windows or plugin activation; it only knows how to manage data.
 */

import { rpc } from "@eleplug/elep/main";
import { v4 as uuid } from "uuid";

/**
 * Represents the data model for a single form submission.
 * This is the core data structure that is created, retrieved, and deleted
 * through the plugin's API.
 */
export type FormData = {
  id: string; // A unique identifier generated by the main process.
  name: string;
  email: string;
  message: string;
};

/**
 * Our simple in-memory "database".
 *
 * Using a Map is ideal here because it allows for efficient O(1) lookups and
 * deletions by the form's unique `id`. In a real-world application, you might
 * replace this with a connection to a persistent database like SQLite.
 */
const formSubmissions = new Map<string, FormData>();

/**
 * The concrete implementation of our plugin's ERPC API.
 *
 * This object's structure must match the `MyPluginApi` type defined in
 * `common/api-types.ts`. Each method here is a procedure that can be called
 * remotely from the renderer process.
 */
export const myPluginApi = {
  /**
   * The 'form' namespace helps organize our API, making it more intuitive
   * for the client to use (e.g., `client.form.getForms.ask()`).
   */
  form: {
    /**
     * Retrieves all current form submissions.
     * @returns {Promise<FormData[]>} A promise that resolves to an array of all form data.
     */
    getForms: rpc.ask(() => {
      console.log("[API:Main] getForms was called. Returning all submissions.");
      // Convert the Map values iterator to an array for the renderer.
      return Array.from(formSubmissions.values());
    }),

    /**
     * Accepts a new form submission, assigns a unique ID, stores it,
     * and returns the complete updated list.
     * @param _ - The ERPC environment object (unused in this procedure).
     * @param data - The form data submitted from the renderer, without an 'id'.
     * @returns {Promise<FormData[]>} The complete list of submissions, including the new one.
     */
    submitForm: rpc.ask((_, data: Omit<FormData, "id">) => {
      console.log("[API:Main] Received a new form submission:", data);

      const newSubmission: FormData = {
        ...data,
        id: uuid(), // Generate a unique ID for the new entry.
      };

      formSubmissions.set(newSubmission.id, newSubmission);
      console.log(
        `[API:Main] Stored submission with ID: ${newSubmission.id}. Total: ${formSubmissions.size}`
      );

      // DESIGN NOTE: Returning the entire updated list simplifies state management
      // on the frontend. The renderer can just replace its local state with this list.
      return Array.from(formSubmissions.values());
    }),

    /**
     * Deletes a form submission based on its ID.
     * @param _ - The ERPC environment object (unused).
     * @param id - The unique ID of the form submission to delete.
     * @returns {Promise<FormData[]>} The complete list of submissions after deletion.
     */
    deleteForm: rpc.ask((_, id: string) => {
      const wasDeleted = formSubmissions.delete(id);

      if (wasDeleted) {
        console.log(
          `[API:Main] Deleted submission with ID: ${id}. Remaining: ${formSubmissions.size}`
        );
      } else {
        // It's good practice to log cases where an operation has no effect.
        console.warn(
          `[API:Main] Attempted to delete a non-existent submission with ID: ${id}`
        );
      }

      return Array.from(formSubmissions.values());
    }),
  },
};

/**
 * Defines the complete shape of the ERPC API that this plugin exposes to the renderer.
 *
 * This type is constructed using the `rpc` procedure builders from `@eleplug/erpc`,
 * ensuring that the type definition perfectly matches the expected procedure signatures.
 *
 * It will be used in the renderer process to create a strongly-typed client:
 * `const client = await getService<MyPluginApi>();`
 */
export type MyPluginApi = typeof myPluginApi;
