import serbin from '@eleplug/serbin';
import type { ServerHttp2Stream } from 'http2';
import type {
  ChannelId,
  ControlChannel,
  IncomingStreamChannel,
  JsonValue,
  MaybePromise,
  OutgoingStreamChannel,
  ServerSignal,
} from '@eleplug/h2';
import { AsyncEventEmitter, FrameParser, H2ChannelBase } from '@eleplug/h2';

/**
 * Implements the server-side `ControlChannel` over an HTTP/2 stream.
 * It is responsible for receiving control messages from the client and sending
 * both control messages and `ServerSignal`s back to the client.
 */
export class H2ServerControlChannel
  extends H2ChannelBase<ServerHttp2Stream>
  implements ControlChannel
{
  private readonly messageEvents = new AsyncEventEmitter<{
    message: (data: JsonValue) => MaybePromise<void>;
  }>();

  constructor(stream: ServerHttp2Stream) {
    const parser = new FrameParser();
    super(stream, parser);

    stream.pipe(parser);

    parser.on('data', async (frame: Buffer) => {
      try {
        const message = serbin.from(frame);
        await this.messageEvents.emitAsync('message', message as JsonValue);
      } catch (err: any) {
        this.parser.destroy(err);
      }
    });
  }

  public send(data: JsonValue): Promise<void> {
    const payload = Buffer.from(serbin.byteify(data));
    return this.sendFrame(payload);
  }

  /**
   * Sends a special signal to the client over the control channel.
   * This is used to request that the client open a new stream channel, enabling
   * server-initiated streams.
   * @param signal The signal to send.
   */
  public sendSignal(signal: ServerSignal): Promise<void> {
    const payload = Buffer.from(serbin.byteify(signal));
    return this.sendFrame(payload);
  }

  /**
   * Internal helper to enforce the replacement semantic for message handlers.
   * @private
   */
  private _setListener(
    handler: (msg: JsonValue) => MaybePromise<void>,
    once: boolean,
  ): void {
    this.messageEvents.removeAllListeners('message');
    const eventHandler = once
      ? this.messageEvents.once.bind(this.messageEvents)
      : this.messageEvents.on.bind(this.messageEvents);
    eventHandler('message', handler);
  }

  public onMessage(handler: (data: JsonValue) => MaybePromise<void>): void {
    this._setListener(handler, false);
  }

  public onceMessage(handler: (data: JsonValue) => MaybePromise<void>): void {
    this._setListener(handler, true);
  }
}

/**
 * Implements both `IncomingStreamChannel` and `OutgoingStreamChannel` for the
 * server over a single bidirectional HTTP/2 stream.
 */
export class H2ServerStreamChannel
  extends H2ChannelBase<ServerHttp2Stream>
  implements IncomingStreamChannel, OutgoingStreamChannel
{
  public readonly id: ChannelId;
  private readonly dataEvents = new AsyncEventEmitter<{
    data: (chunk: JsonValue) => MaybePromise<void>;
  }>();

  /**
   * @param stream The underlying server HTTP/2 stream.
   * @param channelId The channel's unique ID. For client-initiated streams, this
   * is typically the stream ID. For server-initiated streams, it's a UUID
   * generated by the server transport.
   */
  constructor(stream: ServerHttp2Stream, channelId?: ChannelId) {
    const parser = new FrameParser();
    super(stream, parser);
    this.id = channelId ?? String(stream.id);

    stream.pipe(parser);

    parser.on('data', async (frame: Buffer) => {
      try {
        const message = serbin.from(frame);
        await this.dataEvents.emitAsync('data', message as JsonValue);
      } catch (err: any) {
        this.parser.destroy(err);
      }
    });
  }

  public send(chunk: JsonValue): Promise<void> {
    const payload = Buffer.from(serbin.byteify(chunk));
    return this.sendFrame(payload);
  }

  /**
   * Internal helper to enforce the replacement semantic for data handlers.
   * @private
   */
  private _setListener(
    handler: (msg: JsonValue) => MaybePromise<void>,
    once: boolean,
  ): void {
    this.dataEvents.removeAllListeners('data');
    const eventHandler = once
      ? this.dataEvents.once.bind(this.dataEvents)
      : this.dataEvents.on.bind(this.dataEvents);
    eventHandler('data', handler);
  }

  public onData(handler: (chunk: JsonValue) => MaybePromise<void>): void {
    this._setListener(handler, false);
  }

  public onceData(handler: (chunk: JsonValue) => MaybePromise<void>): void {
    this._setListener(handler, true);
  }
}